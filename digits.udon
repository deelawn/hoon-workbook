# Digits

Let's write a generator that takes a `@ud` and return a list of its digits.

```
!:
:-  %say
|=  [* [n=@ud ~] ~]
:-  %noun
=|  lis=(list @ud)
|-  ^+  lis
?:  (lte n 0)
  lis
%=  $
  n    (div n 10)
  lis  (mod n 10)^lis
==
```

We're creating a [`%say` generator](/docs/tutorials/generators). That means we
need some "boilerplate" code in the format of `[%say [%noun "data"]]`:

```
:-  %say
|=  [* [n=@ud ~] ~]
:-  %noun
```

The head is the literal `%say`.

In the tail is the gate and its sample: `|=  [* [n=@ud ~] ~]`. This is
where we describe any arguments we are expecting to be passed in when the
generator is called. We are expecting data of type `@ud`. We give the da the face
`n` to the passed-in data so that we can easily use it later.

Also in the tail is another `cell`, its head indicating to the `dojo` how to
print the value we are creating. In this case, we use the generic `%noun`.

The tail of our second cell is the product of the rest of the program.

```
=|  lis=(list @ud)
```

We use the above code to construct a `list` of `@ud` by cutting up the `@ud` we
got passed and so we add a face onto that type. This list is empty until we
manipulate it further.

```
|-  ^+  lis
?:  (lte n 0)
  lis
```

`|-` creates a gate that functions as a recursion point.

We are actually able to reuse `lis` as defining
the kind of thing we are going to produce. The `^+` rune is the sibling of the
`^-` rune for casting. `^+` is used to cast by example, and it saves us typing
out the definition of a type that we already have an instance of. It's useful
when using a complicated type.

`?:` checks if the statement that follows is true or false. If it's true that
`n` is less than or equal to 0, we simply return `lis`. Otherwise, we branch to
the following operations:

```
%=  $
  n    (div n 10)
  lis  (mod n 10)^lis
==
```

`%=` is the rune that allows us to take a wing with any number changes, in the
form of a list. Our list has two elements that represent such changes, contained
in a `$` expression to perform recursion.

The first change divides `n` by 10, and assigning that product as the new value
for `n`.

The second change prepends the product of `n` modulo 10 to `lis` (`x^y` is an
alternative syntax for `[x y]`). `mod` takes the remainder from dividing `n` by
+10.

These operations will pull each digit out of `n` and put it into a `list`.

* TODO What if we do this with vases? Can we accept a vase, map it to whatever
the correct value would be to extract each digit of the number in whatever base
we are interpreting it in?

* TODO from Rob: we need a few exercises here. Maybe asking the reader to
make one that accepts a vase could be one?
