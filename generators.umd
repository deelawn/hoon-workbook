Generators are the most straightforward way to write programs for Urbit. They are used for doing computations that do not require persistence. This could be anything from listing directory contents, to running unit tests, to fetching the contents of a url. 

There are four kinds of generators: naked, `%say`, `%get`, and `%ask`. Let's take a look at naked generators.

A naked generator is simply a `gate`. A `gate` is an anonymous function that takes a `sample` and produces a `noun`. All you need to do is write a `gate` and put it into file in the gen directory. 
Let's take a look at a very simple one.

```
|=  a=*
a
```

This generator takes one argument of any noun and produces it without any changes. If we put this into a file named `echo.hoon` in the gen directory, we could then run it like so.

```
> +echo 42
42
> +echo "asdf"
[97 115 100 102 0]
```

So what exactly is happening here? The first result is as expected. We pass in 42 and get 42 back. But what about when we pass in `"asdf"`? We just get a pile of numbers back! This has to do with the type of data it is. All `atoms` are just numbers, and how they are interpreted is a matter of what `aura` is being applied to them. At the moment, we haven't specified an `aura`, leaving the pretty printer to fend for itself. `"asdf"` is a `tape` which is simply a `list` of `cords`. A `cord` is a a string of UTF-8 characters packed in Least Significant Byte Order (LSB). When used as part of a `tape` the `cord` is only a single character. This convention of a `list` of `cords` is easier to work with than working directly with `cords`.

We can actually tell the `dojo` to apply a specific aura to the output of our generator to get a better output. 

```
> _tape +echo "asdf"
"asdf"
```

Let's add another argument to our generator. 

```
|=  [a=@ud b=@ud]
(add a b)
```

Let's go ahead and save this as `add.hoon` in our gen directory. Once we have done this we can run our generator again.

```
> +add [3 4]
7
```

You may notice our generator takes a `cell` containing two `@ud`. This is actually one of the limitations of naked generators. We can only pass one argument. We can get around this of course by passing a `cell` but it's certainly less than ideal. A naked generator can also not be called without an argument. This brings us to `%say` generators.

`%say` generators
=================

A `%say` generator is a `cell` the head of which is `%say` and the tail of which is a `gate` that produces a `cask`. A `cask` is pair of a `mark` and some data. You can think of a `mark` as something akin to a MIME type. It describes the data in some way, be it generically such as `%atom` or a standard such as `%json` or even application specific data structures like `%talk-command`. The tail is simply the data.

Let's take an example of a `%say` generator.

```
:-  %say
|=  *
:-  %noun
(add 40 2)
```

And it's output when run.

```
> +add
42
```

Notice that this generator currently takes no arguments. We'll address that in a moment. For now let's focus on the format of the `%say` generator.

```
:-  %say
```

Recall that the rune `:-` is used to produce a cell and that the head of the cell we want to produce needs to be `%say`. 

```
|=  *
:-  %noun
(add 40 2)
```

We now need to create the tail of our `cell`. This gate will itself produce a `cask`. Here we've opted to just use the `mark` of `%noun`. The tail of the `cask` will be our actual data, in this case we are just adding 40 and 2 together but here we could do whatever we needed to in order to produce the correct data for whatever our `%say` generator is supposed to do. 

Let's convert our generator into being something a little more useful. 

```
:-  %say
|=  [* [a=@ud b=@ud ~] ~]
:-  %noun
(add a b)
```

Here again we're creating a `%say` generator but the sample of our gate is a little different than before. Previously we used `*` to indicate the subject was any `noun`, not really concerning ourselves with how it would get called. Now we'd like to have our own arguments to make this a little more usable.

```
|=  [* [a=@ud b=@ud ~] ~]
```

The sample in this `gate` is a tuple of three parts. The first part we simply allow any `noun`. We'll come back to this in a bit.

The second part is a `list` of arguments we want to accept. Here we want to take two `@ud` and add them.

The final part is a `list` of named arguments. Here we've opted to not use any.

```
> +add 40 2
42
```

Let's take a look at the first part of the subject now.

The first thing that gets passed is a tuple containing information about the state of the urbit ship. 

```
[now=@da eny=@uvJ bec=beak]
```

`now` is the current time.
`eny` is 64 bytes of entropy for seeing random number generators.
`bec` is the current `beak` which contains the current ship, desk, and case. (insert links to the docs on each of those things)

Let's take a look at an example of using these. 

```
:-  %say
|=  [[now=@da eny=@uvJ bec=beak] [n=@ud ~] ~]
:-  %noun
(~(rad og eny) n)
```

Now our sample has put faces on all of the standard arguments so we can easily access them.

```
(~(rad og eny) n)
```

Here we want to pull the `rad` arm out of the `og` core with the subject of `eny`. `eny` is our entropy value, so this is used to seed the generator. the `rad` arm will give us a psuedorandom number between 0 and `n`.

If saved in the gen directory, we can run this generator like so.

```
> +dice 6
0
> +dice 6
5
> +dice 6
2
```

`%ask` generators
=================

`%ask` generators are used for creating interactive generators. Let's look at an example.

```
/-  sole
/+  generators
=,  [sole generators]
:-  %ask
|=  *
^-  (sole-result (cask tang))
%+  print    leaf+"What is your favorite color?"
%+  prompt   [%& %prompt "color: "]
|=  t=tape
%+  produce  %tang
?:  =(t "blue")
  :~  leaf+"Oh. Thank you very much."
      leaf+"Right. Off you go then."
  ==
:~  leaf+"Aaaaagh!"
    leaf+"Into the Gorge of Eternal Peril with you!"
==
```


First we need to bring in some of the types we are going to need from `sole` and gates we will use from `generators`.

`/-` is a Ford rune used to import types from `sur`.

`/+` is a Ford rune used to import libraries from `lib`.

`=,` is a rune that allows us to expose a namespace. We do this to avoid having to do `sole-result:sole` instead of `sole-result` or `print:generators` instead of `print`.

Just as `%say` generators, `%ask` generators need to produce a `cell` the head of which specifies what kind of generator we are running.

With `|=  *` we create a gate and ignore the standard arguments we are given because we're not using them. 

`^-  (sole-result (cask tang))`

Buckle up because we are about to go through a fair bit of new terminology.

`%ask` generators need to have the second half of the cell be a gate that produces a `sole-result` in this case one that particularly contains a `cask` of `tang`.

It's not important that we know the details of `sole-result` at this point but you can read about it [here](link to documentation if that ever gets written). For now it's enough, to know that this it the type we need to produce with our generator. 

A `cask` is a pair of a `mark` name and a `noun`. A `mark` can be thought of as a sort of MIME type for data. 

A `tang` is a `list` of `tank` and a `tank` is a structure for printing data that there are three types: `leaf`, `palm`, and `rose`. A `leaf` is for printing a single noun, a `rose` is for printing rows of data, and a `palm` is printing backstep indented lists.


Having imported `generators` we get several gates that we need. There are 6 gates:

1. `print`
2. `prompt`
5. `parse`
3. `curl`
4. `no-product`
6. `produce`

`print` is used for printing a `tank` to the console.

`prompt` is used to construct a prompt for the user to input information into.

`parse` is used to parse the user input as it will be some form of typed data. For example, you can use `parse` to make sure that when you ask for a ship name, the user is only giving you a valid ship name.

`curl` is used to make http requests and is used only in `%get` generators.

`no-product` is used when the result of the `%ask` generator will be empty.

`produce` is the final gate we are interested in and it is used to construct the final output of the generator.

Let's look at some of these in the context of our `axe` generator

```
%+  print    leaf+"What is your favorite color?"
```

`%+` is the rune to call a gate and our gate `print` takes one argument which is a `tank` to print.

 The `+` here is syntactic sugar for `[leaf "What is your favorite color?"]` that just makes it slightly easier to write.
 
```
%+  prompt   [%& %prompt "color: "]
```

`prompt` takes a single argument that is a tuple. The first element of tuple is a flag indicating if what the user typed should be echo'd out to them or hidden. `%&` will produce echo'd output and `%|` will hide the output for use in passwords or other secret text. See loobean documentation if this is unclear.

The second argument is intended to be information to use to create autocomplete options for the prompt but this is as of the time of this writing, unimplemented.

The final argument is a `tape` of what the prompt should look like.

```
|=  t=tape
%+  produce  %tang
?:  =(t "blue")
  :~  leaf+"Oh. Thank you very much."
      leaf+"Right. Off you go then."
  ==
:~  leaf+"Aaaaagh!"
    leaf+"Into the Gorge of Eternal Peril with you!"
==
```

Our gate here takes a `tape` that was produced by `prompt` if we needed another type of data we could use `parse` to obtain it.

The rest of this generator should be understandable at this point.

One quirk that you should be aware of is that `tang` prints in reverse order from how it is created. The reason for this is that `tang` was originally created to display stack trace information, which you want in reverse order. This leads to the annoyance that in this case we either have to specify our messages backwards or construct them in the order we want and then `flop` the `list` This is a [known issue](https://github.com/urbit/arvo/issues/840) and will be resolved at some point.


`%get` generators
=================

